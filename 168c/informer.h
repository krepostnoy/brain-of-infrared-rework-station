/* Тема, в которой обсуждается этот проект
  (link to the topic that discusses this development):
  https://clck.ru/JNqKg
  https://clck.ru/R5pNq
  https://clck.ru/SCNst */
/* Крайнее редактирование 01.01.2023.
  Успешная компиляция проверена в arduino IDE v1.8.15. Все используемые библиотеки имеются в архиве.
  Эта версия самая компактная, специально оптимизируется под использование дешёвых 
  комплектующих: плата arduino на основе микроконтроллеров AtMega168p / 328p, (5v / 16MHz); LCD1602a без i2c;
  один модуль MAX6675; самодельная (или покупная) аналоговая (резистивная) клавиатура на 3 кнопки;
  самодельная (или покупная) 2х-канальная плата реле на 12в (1й канал реле - управление ON/OFF термостол, 
  2й канал реле - управление ON/OFF охладителем силовой платы) (не обязательно);
  одно твердотельное реле типа SSR-40DA - SSR-15DA, или его самодельный аналог; 1 вентилятор на 12в (не обязательно);
  самодельная схема контроля перехода синусоиды сетевого напряжения через
  0 вольт ZCC (Zero Crossing Control) желательно, но не обязательно.
  Здесь только канал верхнего нагревателя. Термостол (нижний нагреватель) можно
  использовать любой, имеющийся в наличии, не важно, с ручным он, или с автоматическим управлением.
  Несмотря на наличие только канала управления верхним нагревателем, контроллер
  имеет широкий набор функций: автоматически завершает пайку при потере контакта с термодатчиком; позволяет строить график
  температура/время и отображать подаваемую в процессе пайки на излучатель мощность в программе SerialPortPlotter -
  (https://github.com/CieNTi/serial_port_plotter/releases/tag/v1.2.0),
  или в программе irsp.exe© от @Dmitrysh (есть в архиве русскоязычная и англоязычная версии) на мониторе ПК.
  Настройки для SerialPortPlotter:  BAUD=9600, POINTS=600, Y STEP=12, MIN=0, MAX=250.
  Контроллер строит график и в SerialPortPlotter версии от @geleos27 -
  (https://drive.google.com/drive/folders/1MJODRkzjEhu9_pDdhrgusmGDYtArU51c).
  Номер com-порта в программе выберите тот, к которому подключена arduino.
  В программе irsp.exe© от @Dmitrysh, после закрытия окна этой программы, в её папке 
  запуска появится лог температур и мощностей.
  Выбрать программу для построения графика возможно только перед компиляцией скетча, закомментировав,
  либо раскомментировав, строку [ #define SerialPortPlotter 1 ] во вкладке Setting.
  Если выбрали ПО SerialPortPlotter, то на время отладки контроллера, подбора коэффициэнтов ПИД ВИ,
  возможно выводить, кроме температуры и мощности, в окне программы графики вклада каждой из составляющих P.I.D.
  Для этого нужно раскомментировать строку [ #define SppBigdata 1 ] перед компиляцией скетча. После настройки 
  коэффициэнтов эту строку желательно снова закомментировать перед компиляцией скетча.
  При старте пайки активируется выход на реле управления вентиляторами охлаждения симисторов и
  контроллера, активный уровень высокий (HIGH), и красный мигающий светодиод.
  1) пищалка = А3 (pin.26 AtMega168p)
  2) Аналоговая клавиатура = А5 (pin.28 AtMega168p)
  3) Вход детектора ноля (ZCC) = 2 (pin.32 AtMega168p)
  4) выход на управление верхним излучателем = 3 (pin.1 AtMega168p)
  5) LCD1602: ( rs = 4, en = 5, d4 = 6, d5 = 7, d6 = 8, d7 = 9 )(pin's.2,9,10,11,12,13 AtMega168p)
  6) пин flash LED и охладителя симисторов и контроллера = A2 (pin.25 AtMega168p)
  7) преобразователь термопары MAX6675:
  SO = 12 (DO=(SO), pin.16 AtMega168p)
  CStop = 11 (CS, pin.15 AtMega168p)
  CLK = 10 (SCK=(CLK), pin.14 AtMega168p)
  8) пин = А6 (pin.19 AtMega168p) в этом варианте не задействован
  9) пин управления включением и отключением термостола = А0 (pin.23 AtMega168p)
  10) пин RX = 0 (pin.30 AtMega168p)
  11) пин TX - 1 (pin.31 AtMega168p)
  12)пин DTR = pin.29 AtMega168p (reset), но через керамический конденсатор 0.1 mkF
  Дополнение:
  1. Автономный термостол включается каждый раз при старте пайки и выключается после 
  неё пином А0 (выход на реле управления ON/OFF термостола), активный уровень низкий (LOW).
  2. Излучатель (нагреватель) включится после короткого нажатия кнопки ВВЕРХ (UP) во время пайки, 
  или по достижении на термопаре возле чипа температуры, заданной до компиляции скетча,
  во вкладке Setting, в строке [ #define degree_Celsius ]. По умолчанию установлено 130°С и
  это значение можно изменять только перед компиляцией скетча.
  3. Выход на реле управления вентиляторами охлаждения платы после завершения пайки 
  в этой версии не реализован.
  4. Выключить охладитель платы можно из режима IDLE клавишей ВЛЕВО (LEFT). В этой версии не задействовано.
  5. включить охладитель платы в режиме IDLE можно коротким нажатием
  клавиши ВПРАВО (RIGHT)(это на случай если вы прервали профиль, но плата горячая
  и вам необходимо её по-быстрому охладить, или просто жарко
  и охладитель используется как вентилятор :) ). В этой версии не задействовано.
  6. Теперь профиль хранится в виде структуры, что уменьшает
  занимаемое скетчем место и сохраняет EEPROM от лишних перезаписей.
  7. параметры сохраняются в EEPROM так: меняем параметр, жмём и удерживаем 5+ секунд кнопку ОК,
  параметр сохранится и контроллер выйдет в режим IDLE.
  8. Логика ПИД ВИ заменена на предложенную @Dmitrysh https://clck.ru/e58xt -
  "работать не по конечному значению ошибки, а по измерению температуры.".
  Эта логика особенно актуальна для "быстрых" излучателей (галогенки, открытая спираль, кварцевая панель).
  Также присутствует и классический вариант расчета, он закомментирован.
  При настройке параметров ПИД обращайте внимание на коэффициенты деления составляющих P, I, D 
  внутри функции Pid1 в теле скетча!!!  Сейчас делители заданы так: 
  Для P делитель 10,
  Для I делитель 1000,
  Для D делителя нет.
  Для керамического излучателя может потребоваться заменить 
  делитель на 10000 для I, а также ввести множитель 10 для D.
  Если будет много, или мало какой-то составляющей,
  перед следующей компиляцией измените соответствующий коэффициент деления.
  9. Оптимизировано отображение параметров на дисплее во всех режимах. Замер и вывод
  температуры на дисплей и в COM-порт выделены в отдельные функции
  и вызываются 2 раза в скетче - уменьшился размер кода.
  10. Состояние для attachInterrupt в теле скетча нужно задать под свою версию схемы (ZCC) контроля
  перехода напряжения сети через ноль (FALLING или RISING). Если используется 
  ZCC по схеме из архива, то нужно указать RISING. Важно! - В скетче вход внешнего прерывания подтянут 
  внутренним резистором к плюсу питания, это нужно учитывать при использовании внешней схемы ZCC!
  11. Профилей можно настроить 5, максимальное число шагов каждого профиля ограничено 4 (программа
  irsp.exe© от @Dmitrysh выводит названия каждого из пяти профилей, но их названия нельзя изменить).
  12. Одновременно со стартом профиля и включением термостола, активируется преднагрев ВИ небольшим % 
  мощности без использования ПИД. В меню можно установить мощность преднагрева от 0 до 25%. 
  Когда будет достигнута температура старта ВИ, он перейдет под управление ПИД.
  13. Мощность подаваемую на излучатель (нагреватель), как минимальную, так и максимальную,
  можно задать для каждого шага.
  14. Добавлена проверка на корректность ввода температуры по шагам,- последующая
  температура не должна быть меньше предыдущей.
  15. Т.к. используется аналоговая (резистивный делитель) клавиатура, значения для кнопок в блоке
  [ { {PIN_UP, 345},
    { PIN_DOWN, 412},
    { PIN_OK, 212} ]
  во вкладке Setting, нужно выставить именно для своего экземпляра клавиатуры.
  Пример вычисления значений:
  http://arduinolab.pw/index.php/2015/12/05/rezistivnaya-klaviatura-princip-raboty/
  16. Изменена логика работы кнопок. Для них используется библиотека ClickBtnLong.h,
  написанная @Watashi (имеется в архиве).
  17. Короткое нажатие кнопки OK - запуск пайки. Короткое нажатие кнопки ОК в режиме пайки, переводит контроллер в состояние IDLE. 
  18. Удержание 5+ секунд кнопки  OK в IDLE - вход в меню. Если находимся в меню, то долгое нажатие ОК сохранит сделанные в меню 
  изменения и выведет контроллер в состояние IDLE.  
  19. Перемещение по пунктам меню - кнопки ВВЕРХ (UP) и ВНИЗ (DOWN).
  20. Если нужно изменить значение в пункте меню, короткое нажатие ОК переводит кнопки ВВЕРХ (UP) и ВНИЗ (DOWN) в режим 
  редактирования, при этом в верхней строке появляются стрелки в качестве индикатора режима редактирования выбранного 
  параметра пункта меню. После редактирования параметра, короткое нажатие кнопки ОК переведёт кнопки ВВЕРХ (UP) 
  и ВНИЗ (DOWN) обратно в режим перемещения по пунктам меню. 
  21. Удержание 5+ секунд кнопки ВНИЗ (DOWN) в IDLE запустит перезапись параметров текущего
  профиля на параметры встроенного тестового профиля.
  22. Перед компиляцией скетча, закомментировав строку [ #define SetInterrupt 0 ],
  можно отказаться от использования внешней схемы контроля перехода напряжения сети
  через ноль вольт (ZCC). При этом будет работать прерывание по таймеру 2, 
  под управлением библиотеки MsTimer2.h.
  23. Любой профиль теперь можно использовать для реализации управления термостолом, 
  вместо управления верхним излучателем, для этого число шагов в профиле должно быть 
  установлено равным 1. В этом случае, при длительности (DWELL) шага = 0, заданной в меню, 
  нагрев и удержание температуры с заданной для шага скоростью будет происходить
  до момента нажатия кнопки ОК. Чтобы после старта профиля управления термостолом 
  начался процесс роста температуры, нужно его принудительно вручную активировать удержанием 5+ секунд 
  кнопки ВВЕРХ (UP), т.к. по умолчанию, при управлении верхним излучателем, старт 
  управления происходит по значению температуры, заданному в строке 
  [ #define degree_Celsius 130 ] во вкладке Setting. Параметры ПИД для 
  управления термостолом нужно подобрать для конкретного термостола.
  24. После первой загрузки скетча в плату arduino, настоятеьно рекомендуется произвести
  инициализацию значениями по умолчанию всех доступных 5 профилей, для того, чтобы
  случайные значения из EEPROM не портили изображение на LCD!
  25. /* //if (counter >= profile.dwellTimerStep[currentStep - 1]) { //если счётчик больше установленного времени
           Строка выше является верной! Для обеспечения возможности использовать контроллер
           для управления не только верхним излучателем, а, при необходимости, вместо этого,
           для управления нагревом и долговременным удержанием заданной уставки термостолом,
           не имевщим изначально таких функций, немного изменено условие в этой строке. Теперь
           при задании длительности любого шага равной 0, профиль никогда не сможет завершиться.
           Это не совсем правильно, но так сделано для упрощения кода. Измененная строка
           расположена ниже этого текстового блока.
        if (counter == profile.dwellTimerStep[currentStep - 1]) //если счётчик равен установленному времени */

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/*  byte Pid1(double temp, byte ust, byte kP, byte kI, byte kd) {  //классическая версия ПИД по величине ошибки
  byte out = 0;
  static float ed = 0;
  e = (ust - temp);                 //ошибка регулирования
  p =  (kP * e);                    //П составляющая
  integra = (integra < i_min) ? i_min : (integra > i_max) ? i_max : integra + (kI * e) / 100; //И составляющая
  d = kd * (e - ed) * 10;           //Д составляющая
  ed = e;
  out = (p + integra + d < profile.min_pwr_TOPStep[currentStep - 1]) ? profile.min_pwr_TOPStep[currentStep - 1] : (p + integra + d > profile.max_pwr_TOPStep) ? profile.max_pwr_TOPStep[currentStep - 1] : p + integra + d;
  return out;
  }  */
